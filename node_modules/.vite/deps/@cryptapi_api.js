import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod
} from "./chunk-OQR4HGLN.js";

// node_modules/@cryptapi/api/index.js
var require_api = __commonJS({
  "node_modules/@cryptapi/api/index.js"(exports, module) {
    var _baseURL, _CryptAPI_static, _request_fn;
    var _CryptAPI = class _CryptAPI {
      constructor(coin, ownAddress, callbackUrl, parameters = {}, caParams = {}) {
        _CryptAPI.getSupportedCoins().then((validCoins) => {
          if (!validCoins.hasOwnProperty(coin)) {
            throw new Error("The cryptocurrency/token requested is not supported.");
          }
        });
        this.coin = coin;
        this.ownAddress = ownAddress;
        this.callbackUrl = callbackUrl;
        this.parameters = parameters;
        this.caParams = caParams;
        this.paymentAddress = "";
      }
      /**
       * Gets all the supported cryptocurrencies and tokens from the API
       * @returns {Promise<{}|null>}
       */
      static async getSupportedCoins() {
        const info = await this.getInfo(null, true);
        if (!info) {
          return null;
        }
        delete info["fee_tiers"];
        const coins = {};
        for (const chain of Object.keys(info)) {
          const data = info[chain];
          const isBaseCoin = data.hasOwnProperty("ticker");
          if (isBaseCoin) {
            coins[chain] = data;
          } else {
            const baseTicker = `${chain}_`;
            Object.entries(data).forEach(([token, subData]) => {
              coins[baseTicker + token] = subData;
            });
          }
        }
        return coins;
      }
      /**
       * Actually makes the request to the API returning the address.
       * It's necessary to run this before running the other non-static functions
       * @returns {Promise<*|null>}
       */
      async getAddress() {
        var _a;
        if (!this.coin || !this.callbackUrl || !this.ownAddress) {
          return null;
        }
        let callbackUrl = new URL(this.callbackUrl);
        const parameters = this.parameters;
        if (Object.entries(parameters).length > 0) {
          Object.entries(parameters).forEach(([k, v]) => callbackUrl.searchParams.append(k, v));
        }
        let params = { ...this.caParams, ...{
          callback: encodeURI(callbackUrl.toString()),
          address: this.ownAddress
        } };
        const response = await __privateMethod(_a = _CryptAPI, _CryptAPI_static, _request_fn).call(_a, this.coin, "create", params);
        const addressIn = response.address_in;
        this.paymentAddress = addressIn;
        return addressIn;
      }
      /**
       * Checks the logs related to a request.
       * (Can be used to check for callbacks)
       * @returns {Promise<any|null>}
       */
      async checkLogs() {
        var _a;
        if (!this.coin || !this.callbackUrl) {
          return null;
        }
        let callbackUrl = new URL(this.callbackUrl);
        const parameters = this.parameters;
        if (Object.entries(parameters).length > 0) {
          Object.entries(parameters).forEach(([k, v]) => callbackUrl.searchParams.append(k, v));
        }
        callbackUrl = encodeURI(callbackUrl.toString());
        return await __privateMethod(_a = _CryptAPI, _CryptAPI_static, _request_fn).call(_a, this.coin, "logs", {
          callback: callbackUrl
        });
      }
      /**
       * Gets the QRCode for a payment.
       * @param value
       * @param size
       * @returns {Promise<any|null>}
       */
      async getQrcode(value = null, size = 512) {
        var _a;
        const params = {
          address: this.paymentAddress
        };
        if (value) {
          params["value"] = value;
        }
        params["size"] = size;
        return await __privateMethod(_a = _CryptAPI, _CryptAPI_static, _request_fn).call(_a, this.coin, "qrcode", params);
      }
      /**
       * Get information related to a cryptocurrency/token.
       * If coin=null it calls the /info/ endpoint returning general information
       * @param coin
       * @returns {Promise<any|null>}
       */
      static async getInfo(coin = null) {
        const params = {};
        if (!coin) {
          params["prices"] = 0;
        }
        return await __privateMethod(this, _CryptAPI_static, _request_fn).call(this, coin, "info", params);
      }
      /**
       * Gets an estimate of the blockchain fees for the coin provided.
       * @param coin
       * @param addresses
       * @param priority
       * @returns {Promise<any|null>}
       */
      static async getEstimate(coin, addresses = 1, priority = "default") {
        var _a;
        return await __privateMethod(_a = _CryptAPI, _CryptAPI_static, _request_fn).call(_a, coin, "estimate", {
          addresses,
          priority
        });
      }
      /**
       * This method allows you to easily convert prices from FIAT to Crypto or even between cryptocurrencies
       * @param coin
       * @param value
       * @param from
       * @returns {Promise<any|null>}
       */
      static async getConvert(coin, value, from) {
        var _a;
        let params = {
          value,
          from
        };
        return await __privateMethod(_a = _CryptAPI, _CryptAPI_static, _request_fn).call(_a, coin, "convert", params);
      }
    };
    _baseURL = new WeakMap();
    _CryptAPI_static = new WeakSet();
    _request_fn = async function(coin, endpoint, params = {}) {
      const url = coin ? new URL(`${__privateGet(this, _baseURL)}/${coin.replace("_", "/")}/${endpoint}/`) : new URL(`${__privateGet(this, _baseURL)}/${endpoint}/`);
      if (params) {
        Object.keys(params).forEach((key) => url.searchParams.append(key, params[key]));
      }
      const fetchParams = {
        method: "GET",
        headers: {
          referer: __privateGet(this, _baseURL)
        },
        credentials: "include"
      };
      const response = await fetch(url, fetchParams);
      const response_obj = await response.json();
      if (response_obj.status === "error") {
        throw new Error(response_obj.error);
      }
      return response_obj;
    };
    __privateAdd(_CryptAPI, _CryptAPI_static);
    __privateAdd(_CryptAPI, _baseURL, "https://api.cryptapi.io");
    var CryptAPI = _CryptAPI;
    module.exports = CryptAPI;
  }
});
export default require_api();
//# sourceMappingURL=@cryptapi_api.js.map
